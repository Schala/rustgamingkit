pub mod ast {
	use ultraviolet::vec::{
		Vec3,
		Vec4
	};

	/// Wavefront 3D object info
	#[derive(Clone, Debug, PartialEq)]
	pub struct ObjectInfo {
		pub name: Option<String>,
		pub vertices: Option<Vec<Vec4>>,
		pub normals: Option<Vec<Vec3>>,
		pub uvs: Option<Vec<Vec3>>,
		//pub subgroups: Option<Vec<Box<ObjectInfo>>>,
		pub mat_lib: Option<String>,
		pub meshes: Option<Vec<MeshInfo>>,
		pub is_group: bool,
	}

	/// A singular face index set
	pub type FaceIndex = [u32; 3];

	/// A polygon made of face indices
	pub type Face = [FaceIndex; 3];

	/// Wavefront mesh info
	#[derive(Clone, Debug, PartialEq)]
	pub struct MeshInfo {
		pub faces: Option<Vec<Face>>,
		pub material: Option<String>,
		pub smooth: bool,
	}
}

#[cfg(feature = "export")]
pub mod export {
	use std::{
		fmt::Write as FmtWrite,
		fs,
		io::Write as IoWrite,
	};

	use meshio_core::{
		IOError,
		scene::{
			Face,
			Mesh,
			NodeData,
			Scene,
			Vertex
		}
	};

	static BUF_ERR: &str = "Buffer unwritable";
	static FACE_ERR: &str = "Face unwritable";

	pub fn write<'a, 'b>(filepath: &'a str, scene: &'b Scene) -> Result<(), IOError> {
		let mut buf = String::new();
		writeln!(&mut buf, "# Generated by the meshio-wavefront Rust crate").expect(BUF_ERR);
		writeln!(&mut buf).expect(BUF_ERR);

		if let NodeData::Geometry(mesh) = &scene.root.data {
			// positions
			for v in mesh.vertices.iter() {
				writeln!(&mut buf, "v {} {} {}", v.position.x, v.position.y, v.position.z).expect("Vertex unwritable");
			}

			writeln!(&mut buf).expect(BUF_ERR);

			// normals
			for v in mesh.vertices.iter() {
				if let Some(n) = v.normal {
					writeln!(&mut buf, "vn {} {} {}", n.x, n.y, n.z).expect("Normal unwritable");
				}
			}

			writeln!(&mut buf).expect(BUF_ERR);

			// UVs
			for v in mesh.vertices.iter() {
				if v.uvw.len() > 0 {
					writeln!(&mut buf, "vt {} {}", v.uvw[0].x, v.uvw[0].y).expect("UV unwritable");
				}
			}

			writeln!(&mut buf).expect(BUF_ERR);

			// Wavefront uses 1-based indices
			let mut normal_count = 1usize;
			let mut uv_count = 1usize;
			for face in mesh.faces.iter() {
				if let Face::Triangle(t) = face {
					write!(&mut buf, "f ").expect(FACE_ERR);
					for i in t.iter() {
						write!(&mut buf, "{}", *i + 1).expect("Vertex index unwritable");

						if mesh.vertices[*i].uvw.len() > 0 {
							write!(&mut buf, "/{}", uv_count).expect("UV index unwritable");
							uv_count += 1;
						} else {
							write!(&mut buf, "/").expect(FACE_ERR);
						}

						if let Some(_) = mesh.vertices[*i].normal {
							write!(&mut buf, "/{} ", normal_count).expect("Normal index unwritable");
							normal_count += 1;
						} else {
							write!(&mut buf, " ").expect(FACE_ERR);
						}
					}
					writeln!(&mut buf).expect(FACE_ERR);
				}
			}

			match fs::write(filepath, buf) {
				Ok(_) => return Ok(()),
				_ => return Err(IOError {
					msg: "Unable to write to file".to_string(),
				}),
			}
		}

		Err(IOError {
			msg: "No geometry found".to_string(),
		})
	}

	#[cfg(test)]
	mod tests {
		#[test]
		fn test_obj_write() {
			let test_rip = meshio_ninjaripper::read("../ninjaripper/test_data/Mesh_0015.rip",
				meshio_ninjaripper::RipImportCfg::default());
			super::write("Mesh_0015.obj", &test_rip.unwrap()).unwrap();

			let mut ripcfg = meshio_ninjaripper::RipImportCfg::default();
			ripcfg.flags |= meshio_ninjaripper::RipImportFlag::FLIP_X;

			let test_rip_flipped = meshio_ninjaripper::read("../ninjaripper/test_data/Mesh_0015.rip",
				ripcfg);
			super::write("Mesh_0015_flipped.obj", &test_rip_flipped.unwrap()).unwrap();
		}
	}
}

/*#[cfg(feature = "import")]
pub mod import {
	use nom::{
		branch::{
			alt,
			permutation,
		},
		bytes::complete::tag,
		character::complete::{
			char,
			u32
		},
		combinator::{
			opt,
			value
		},
		error::{
			ErrorKind,
			ParseError
		},
		IResult,
		multi::{
			many0,
			many1,
			separated_list1
		},
		number::complete::float,
		sequence::{
			preceded,
			tuple
		}
	};

	use thiserror::Error;

	use ultraviolet::vec::{
		Vec3,
		Vec4
	};

	use crate::{
		etc,
		identifier,
		uvw
	};

	use super::ast::*;

	use meshio_core::parser::vec3ws;

	#[derive(Error, Debug, PartialEq)]
	pub enum ObjImportError {
		#[error("Material not found")]
		Material(String),
		#[error("Material library not found")]
		MaterialLibrary(String),
		#[error("Unknown import error")]
		Unknown,
		#[error("Vertex index out of bounds")]
		VertexIndex(u32),
	}

	impl<I> ParseError<I> for ObjImportError {
		fn from_error_kind(_: I, _: ErrorKind) -> Self {
			ObjImportError::Unknown
		}

		fn append(_: I, _: ErrorKind, other: Self) -> Self {
			other
		}
	}

	/// Parses a 4D vector, of which the last element is optional and defaults to `1.0`, used for vertices
	fn xyzw(input: &str) -> IResult<&str, Vec4> {
		let (input, f4vec) =
            tuple((etc(float), etc(float), etc(float), opt(etc(float))))(input)?;

		Ok((input, Vec4::new(f4vec.0, f4vec.1, f4vec.2, match f4vec.3 {
			Some(val) => val,
			_ => 1.0,
		})))
	}

	/// Parses a face index set
	fn indices(input: &str) -> IResult<&str, FaceIndex> {
		let (input, f) = separated_list1(char('/'), opt(u32))(input)?;
		Ok((input, [
			match f[0] {
				Some(f) => f,
				_ => 0,
			},
			match f[1] {
				Some(f) => f,
				_ => 0,
			},
			match f[2] {
				Some(f) => f,
				_ => 0,
			}
		]))
	}

	/// Parses a mesh
	fn mesh(input: &str) -> IResult<&str, MeshInfo> {
		let (input, data) = tuple((
            opt(etc(usemtl)),
            opt(etc(s)),
            opt(many0(etc(f)))
        ))(input)?;
		
		Ok((input, MeshInfo {
			faces: data.2,
			material: match data.0 {
				Some(m) => Some(m.to_string()),
				_ => None,
			},
			smooth: match data.1 {
				Some(s) => s,
				_ => false,
			}
		}))
	}

	/// Parses an object
	fn obj(input: &str) -> IResult<&str, ObjectInfo> {
		let (input, data) = tuple((
            opt(etc(mtllib)),
            opt(etc(alt((o, g)))),
            permutation((
                opt(many0(etc(v))),
                opt(many0(etc(vn))),
                opt(many0(etc(vt))),
                opt(many0(etc(mesh))),
            )),
        ))(input)?;

		println!("{:?}", data);
		Ok((input, ObjectInfo {
			name: match data.1 {
				Some(n) => Some(n.0.to_string()),
				_ => None,
			},
			mat_lib: match data.0 {
				Some(ml) => Some(ml.to_string()),
				_ => None,
			},
			meshes: data.2.3,
			vertices: data.2.0,
			normals: data.2.1,
			uvs: data.2.2,
			is_group: match data.1 {
				Some(yes) => if yes.1 { true } else { false },
				None => false
			}
		}))
	}

	/// Parses a face
	fn f(input: &str) -> IResult<&str, Face> {
		let (input, f) = preceded(etc(char('f')), alt((
            many1(etc(indices)),
            many1(etc(u32)),
        )))(input)?;
		
		Ok((input, [f[0], f[1], f[2]]))
	}

	/// Parses a group identifier, returning a boolean in addition for `is_group`
	fn g<'a>(input: &'a str) -> IResult<&'a str, (&'a str, bool)> {
		let (input, name) = preceded(etc(char('g')), etc(identifier))(input)?;
		Ok((input, (name, true)))
	}

	/// Parses a poly line
	fn l(input: &str) -> IResult<&str, Vec<u32>> {
		preceded(etc(char('l')), many1(etc(u32)))(input)
	}

	/// Parses an .mtl file usage declaration
	fn mtllib<'a>(input: &'a str) -> IResult<&'a str, &'a str> {
		preceded(etc(tag("mtllib")), etc(identifier))(input)
	}

	/// Parses an object identifier, returning a boolean in addition for `is_group`
	fn o<'a>(input: &'a str) -> IResult<&'a str, (&'a str, bool)> {
		let (input, name) = preceded(etc(char('o')), etc(identifier))(input)?;
		Ok((input, (name, false)))
	}

	/// Parses a smoothing flag
	fn s(input: &str) -> IResult<&str, bool> {
		preceded(etc(char('s')), alt((
            value(false, etc(alt((tag("off"), char('0'))))),
            value(true, etc(alt((tag("on"), char('1'))))),
        )))(input)
	}

	/// Parses a material usage declaration
	fn usemtl<'a>(input: &'a str) -> IResult<&'a str, &'a str> {
		preceded(etc(tag("usemtl")), etc(identifier))(input)
	}

	/// Parses a vertex
	fn v(input: &str) -> IResult<&str, Vec4> {
		preceded(etc(char('v')), etc(xyzw))(input)
	}

	/// Parses a normal
	fn vn(input: &str) -> IResult<&str, Vec3> {
		preceded(etc(tag("vn")), etc(vec3ws))(input)
	}

	fn vp(input: &str) -> IResult<&str, Vec3> {
		preceded(etc(tag("vp")), etc(uvw))(input)
	}

	/// Parses a UV
	fn vt(input: &str) -> IResult<&str, Vec3> {
		preceded(etc(tag("vt")), etc(uvw))(input)
	}

	#[cfg(test)]
	mod tests {
		#[test]
		fn test_cube_usemtl() {
			let cube_obj = include_str!("../test_data/cube_usemtl.obj");
			println!("{:?}", super::obj(cube_obj).unwrap().1);
		}
	}
}*/
